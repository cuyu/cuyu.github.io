---
layout: post
title: "一个关于Python装饰器使用方式产生的问题"
category: Python
tags: [decorator]
date: 2017-09-26
---





```python
class Demo(object):
    @record(1)
    def demo(self):
        a = 1
```

和下面这种方式，装饰器函数输入的函数一个是普通的函数，一个是bounded的函数：

```python
class Demo(object):
    def demo(self):
        a = 1

record(1)(Demo().demo)()
```

原因也很简单，因为前者装饰时目标类型还没有实例化，而后者实际上是对实例化过后的对象中的函数进行的装饰。但因为这种不同，在装饰器中处理时就出现了问题：



因为Python 3取消了bounded函数的机制，上面这种情况就不会出现了？