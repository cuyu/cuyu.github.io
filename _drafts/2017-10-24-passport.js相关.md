---
layout: post
title: "passport.js相关"
category: Javascript
tags: [express]
date: 2017-10-24
---

首先，一个很好的项目例子：[express-4.x-local-example](https://github.com/passport/express-4.x-local-example)。



如果用到了session来存储登陆的信息的话（默认是用了的），必须实现`passport.serializeUser`和`passport.deserializeUser`两个函数，分别用于从user对象中提取一个唯一能代表该user的字符串（从而生成session key），以及通过之前提取的字符串反过来得到user对象。



默认session key在客户端存储在名为`connect.sid`的cookie中，服务端会根据该值来计算并验证登陆信息，具体的流程为：

> ##### 若本次cookie中没有connect.sid，则生成一个 [用secret生成connect.sid]
>
> 1. 用[uid-safe](https://github.com/crypto-utils/uid-safe/blob/master/index.js)生成一个唯一id，记为sessionid，保证每次不重复；
> 2. 把上面的connect.sid制作成 `'s:' + sessionid + '.' + sessionid.sha256(secret).base64()` 的形式，实现在[node-cookie-signature](https://github.com/tj/node-cookie-signature/blob/master/index.js)的sign函数；
> 3. 把sessionid用set-cookie返回给前端；
>
> ##### 若本次cookie中包含connect.sid，则验证它是否是本服务器生成的 [用secret验证connect.sid]
>
> 1. 取出cookie中的connect.sid，形式是上面的 `'s:' + sessionid + '.' + sessionid.sha256(secret).base64()` ；
> 2. 从connect.sid中截取出sessionid=connect.sid.slice(2, connect.sid.indexOf(’.’))；
> 3. 用取出的sessionid再算一次 sessionid.sha256(secret).base64() 记为 mac；
> 4. 截取connect.sid中’.'后的部分与mac对比；[node-cookie-signature](https://github.com/tj/node-cookie-signature/blob/master/index.js)的unsign函数（用上次计算的sha256值和这次计算的sha256值进行比较，只要secret一样，结果就一样）；
> 5. 验证成功的sessionid继续往下走。
>
> ##### 总结
>
> 用secret进行签名保证存在cookie中的connect.sid是本服务器上次生成的。除非知道secret，不然没办法伪造connect.sid中的sessionid，避免知道了sessionid生成算法的人(uid-safe)使用sessionid随便试探来攻击网站。

