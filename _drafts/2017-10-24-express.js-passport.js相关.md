---
layout: post
title: "express.js/passport.js相关"
category: Javascript
tags: [express.js, passport.js]
date: 2017-10-24
---

首先，一个很好的项目例子：[express-4.x-local-example](https://github.com/passport/express-4.x-local-example)。



如果用到了session来存储登陆的信息的话（默认是用了的），必须实现`passport.serializeUser`和`passport.deserializeUser`两个函数，分别用于从user对象中提取一个唯一能代表该user的字符串（从而生成session key），以及通过之前提取的字符串反过来得到user对象。



默认session key在客户端存储在名为`connect.sid`的cookie中，服务端会根据该值来计算并验证登陆信息，具体的流程为：

> ##### 若本次cookie中没有connect.sid，则生成一个 [用secret生成connect.sid]
>
> 1. 用[uid-safe](https://github.com/crypto-utils/uid-safe/blob/master/index.js)生成一个唯一id，记为sessionid，保证每次不重复；
> 2. 把上面的connect.sid制作成 `'s:' + sessionid + '.' + sessionid.sha256(secret).base64()` 的形式，实现在[node-cookie-signature](https://github.com/tj/node-cookie-signature/blob/master/index.js)的sign函数；
> 3. 把sessionid用set-cookie返回给前端；
>
> ##### 若本次cookie中包含connect.sid，则验证它是否是本服务器生成的 [用secret验证connect.sid]
>
> 1. 取出cookie中的connect.sid，形式是上面的 `'s:' + sessionid + '.' + sessionid.sha256(secret).base64()` ；
> 2. 从connect.sid中截取出sessionid=connect.sid.slice(2, connect.sid.indexOf(’.’))；
> 3. 用取出的sessionid再算一次 sessionid.sha256(secret).base64() 记为 mac；
> 4. 截取connect.sid中’.'后的部分与mac对比；[node-cookie-signature](https://github.com/tj/node-cookie-signature/blob/master/index.js)的unsign函数（用上次计算的sha256值和这次计算的sha256值进行比较，只要secret一样，结果就一样）；
> 5. 验证成功的sessionid继续往下走。
>
> ##### 总结
>
> 用secret进行签名保证存在cookie中的connect.sid是本服务器上次生成的。除非知道secret，不然没办法伪造connect.sid中的sessionid，避免知道了sessionid生成算法的人(uid-safe)使用sessionid随便试探来攻击网站。



对应到express中，[express-session]()这个中间件就是用来将cookie中session相关的东西提取出来，并放在`req`对象上新创建的`session`属性中。因此，如果passport.js中用到了session来存储登陆的信息的话，就必须加载[express-session]()中间件，否则你会发现`req.session`是`undefined`的。



**[express]()中中间件加载的顺序很重要，先加载的中间件会被先调用执行**（见[Writing middleware for use in Express apps](http://expressjs.com/en/guide/writing-middleware.html)）。因此，如果某个中间件要依赖另一个中间件，则必须在它之后再加载。比如[express-session]()要用到[cookie-parser]()解析过的`req.cookies`属性，那么加载时就应该这样：

```javascript
app.use(require('cookie-parser')());
app.use(require('express-session')());
```

并且，通常会把所有全局应用的中间件加载的代码放到最前面执行，然后再绑定route对应的处理代码，否则之前绑定的route是不会被之后加载的中间件处理的。比如下面就是一个**错误**的例子：

```javascript
app.get('/', function (req, res) {
  res.send('Hello World!')
})
app.use(require('cookie-parser')());
```

可以这样理解：当一个请求进入时，会按照中间件加载时的顺序“走”一遍所有起作用的中间件（route其实也是中间件，只不过只对某个route起作用），直到走到某个中间件，它告诉请求说你不用再往下走了，直接返回（结果）吧。就和搭积木一样，一定要把“结束单元”搭到最下面，否则“结束单元”下面的单元是不起作用的。



Debug到[express]()的源码中也能看到，每一个请求过来时都会从一个列表中每一层处理一遍，直到某一层结束处理了再返回一个response，这里的每一层其实都是一个中间件。

<img title="2017-10-24-express.js-passport.js相关.png" src="/images/2017-10-24-express.js-passport.js相关.png" width="1767" />
<span class="caption">每一个中间件作为一个Layer放在stack中</span>

每一层会调用它的`handle_request`函数，查看它的源码，可以看到函数签名和我们的中间件是一样的。事实上，`this.handle`是构建Layer时传递进去的函数，也就是中间件函数。

```javascript
Layer.prototype.handle_request = function handle(req, res, next) {
  var fn = this.handle;

  if (fn.length > 3) {
    // not a standard request handler
    return next();
  }

  try {
    fn(req, res, next);
  } catch (err) {
    next(err);
  }
};
```

