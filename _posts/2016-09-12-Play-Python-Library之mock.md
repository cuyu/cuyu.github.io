---
layout: post
title: "Play Python Libraryä¹‹mock"
category: Python
tags: [mock, Play Python Library]
date: 2016-09-12
---

## Why use mock

`mock`ï¼Œåº“å¦‚å…¶åï¼Œæ˜¯ä¸€ä¸ªç”¨æ¥ä¼ªé€ å¯¹è±¡çš„åº“ (ğŸ™ƒ)ã€‚

 æƒ³è±¡ä¸€ä¸ªè¿™æ ·çš„åœºæ™¯ï¼š

> ä½ å¼€å‘äº†ä¸€ä¸ªæ¯”è¾ƒå¤æ‚çš„ç¨‹åºï¼Œå®ƒæ¯æ¬¡éƒ½éœ€è¦è¯»å–å¤–éƒ¨ä¸€ä¸ªæ•°æ®åº“ä¸­çš„æ•°æ®ï¼Œåç»­çš„æ“ä½œéƒ½ä¼šæ ¹æ®è¿™ä¸ªè¯»å–çš„æ•°æ®æ¥è¿›è¡Œã€‚

é¢å¯¹è¿™æ ·çš„ç¨‹åºï¼Œä½ ä¼šå¦‚ä½•å†™æµ‹è¯•çš„ä»£ç ï¼Ÿ

æ˜¯å°†ä¾èµ–çš„æ•°æ®åº“ä¿¡æ¯åœ¨æµ‹è¯•ä»£ç ä¸­ä¹Ÿå®šä¹‰ä¸€ä»½ï¼Ÿè¿˜æ˜¯ä¼ªé€ ä¸€ä»½æ•°æ®åº“ä¸­çš„æ•°æ®ï¼Œç„¶åhackæ‰è¯»æ•°æ®çš„éƒ¨åˆ†ï¼Œç›´æ¥ç”¨ä¼ªé€ çš„æ•°æ®ç”¨äºåç»­æ“ä½œçš„æµ‹è¯•ï¼Ÿ

OKï¼Œä»¥ä¸Šä¸¤ç§æ–¹å¼éƒ½æ˜¯å¯ä»¥è¾¾åˆ°æµ‹è¯•çš„æ•ˆæœçš„ã€‚BUTï¼Œå‰è€…çš„æµ‹è¯•ä»£ç ä¼šä¾èµ–å¤–éƒ¨çš„æ•°æ®åº“ï¼Œå¦‚æœæ•°æ®åº“æœåŠ¡å™¨å‘ç”Ÿå˜åŒ–ï¼Œé‚£ä¹ˆæµ‹è¯•ä»£ç ä¹Ÿè¦è·Ÿç€å˜ï¼›è€Œä¸”å¦‚æœæ¶‰åŠæ•°æ®åº“çš„å†™å…¥ï¼Œä¸ºäº†ä¸å½±å“å¼€å‘ç¯å¢ƒçš„æ•°æ®åº“ï¼Œå¯èƒ½éœ€è¦å•ç‹¬æ­å»ºä¸€ä¸ªæµ‹è¯•ç”¨çš„æ•°æ®åº“ï¼›å³ä½¿æ­å»ºäº†æµ‹è¯•ç”¨çš„æ•°æ®åº“ï¼Œå¦‚æœå¼€å‘ç”¨çš„æ•°æ®åº“é…ç½®å‘ç”Ÿå˜åŒ–ï¼Œæµ‹è¯•è¿™è¾¹ä¹Ÿå¾—è·Ÿç€å˜ï¼Œæƒ³æƒ³å°±å¥½éº»çƒ¦ã€‚è€Œåè€…ä½¿ç”¨Hackçš„æ–¹å¼æ¥å–ä»£æ‰å¤–éƒ¨çš„æ•°æ®åº“è™½ç„¶å¯è¡Œï¼Œä½†æµ‹è¯•ä»£ç ä¼šå˜å¾—éš¾ä»¥ç»´æŠ¤ã€‚

è§£å†³è¿™ä¸ªé—®é¢˜è¿˜æœ‰ä¸€ä¸ªå‡ºè·¯ï¼Œé‚£å°±æ˜¯ç”¨`mock`åº“ä¸­çš„`MagicMock`å¯¹è±¡æ¥æ¨¡æ‹Ÿå’Œä¼ªé€ ä¸€ä¸ªæ•°æ®åº“å¯¹è±¡ï¼Œå®ƒå¸®ä½ å¹²äº†ä½ è¦å¹²çš„hackçš„æ´»ï¼Œç”¨è¿™ç§æ–¹å¼è¦æ¯”ç›´æ¥hackæºä»£ç è¦æ›´æ˜“äºç»´æŠ¤ã€‚

## Play with mock

### MagicMock

ç®€å•æå‡ ç‚¹ï¼š

- è®¿é—®`MagicMock`ç±»å‹çš„å¯¹è±¡ä¸­æœªå®šä¹‰çš„å±æ€§ä¼šåˆ›å»ºä¸€ä¸ªæ–°`MagicMock`å¹¶ç»‘å®šåˆ°è¿™ä¸ªå±æ€§ã€‚
- `MagicMock`ç±»å‹æœ‰ä¸€äº›ç‰¹æ®Šçš„å±æ€§ï¼š
  - é€šè¿‡è®¾å®š`MagicMock`ç±»å‹å¯¹è±¡çš„`return_value`å±æ€§ï¼Œä¼šæŠŠè¿™ä¸ªå±æ€§çš„å€¼ç»‘å®šä¸º`__call__`æ–¹æ³•çš„è¿”å›å€¼ã€‚
  - é€šè¿‡è®¾å®š`MagicMock`ç±»å‹å¯¹è±¡çš„`side_effect`å±æ€§ï¼Œå¯ä»¥è¾¾åˆ°ä½¿`__call__`æ–¹æ³•æ ¹æ®è¾“å…¥æ¥è¿”å›ä¸åŒå€¼çš„æ•ˆæœã€‚

<!--break-->

å…¶ä»–å…³äº`MagicMock`çš„ä¸€äº›ç‰¹æ€§çœ‹ä¸‹é¢çš„ä¾‹å­å¥½äº†ï¼š

```python
from mock import MagicMock

if __name__ == '__main__':
    # MagicMock object will generate a new MagicMock object if you visit to a undefined attribute.
    m0 = MagicMock()
    print m0.aaa

    # You can define some attributes in the construct function of MagicMock conveniently.
    m1 = MagicMock(aaa=1, bbb=2)
    print m1.aaa, m1.bbb
    # By `del` method, you can delete an attribute of MagicMock object, and it will cause AttributeError when you visit the deleted attribute.
    del m1.ccc
    try:
        print m1.ccc
    except AttributeError, e:
        print 'AttributeError'

    # Use spec to limit a set of attributes, will cause AttributeError when you visit attribute out of the spec list.
    m2 = MagicMock(spec=['aaa', 'bbb'])
    print m2.aaa
    try:
        print m2.ccc
    except AttributeError, e:
        print 'AttributeError'

    # Use spec to input a object can make the MagicMock object pass `isinstance` test.
    dd = dict()
    m3 = MagicMock(spec=dd)
    print isinstance(m3, dict)

    # Set the `return_value` to a MagicMock object will let the calling of the object always return the same value.
    m4 = MagicMock()
    m4.return_value = 6
    print m4(4, 'aaa'), m4([1,2,3])

    # Use side_effect to bind a method to the MagicMock object so that it can return different values according to the inputs.
    m4 = MagicMock(side_effect=lambda value: value * 2)
    print m4(3), m4('abc')

    # Can also bind a iterable object to side_effect. In this case, the return value will be the traversal of the iterable object.
    # And has nothing to do with the inputs.
    m5 = MagicMock()
    m5.side_effect = [5, 'hi']
    print m5(2), m5()
```

### patch

é€šè¿‡`patch`å¯ä»¥æ–¹ä¾¿åœ°æ›¿æ¢æ‰ç›®æ ‡ä½ç½®çš„å¯¹è±¡ï¼Œä»è€Œè¾¾åˆ°mockçš„ç›®çš„ã€‚`mock`å¾ˆè´´å¿ƒåœ°å¸®`patch`å†™äº†è£…é¥°å™¨å’Œwithè¯­å¥çš„å®ç°ï¼Œè®©æ›¿æ¢å¯¹è±¡çš„scopeæ›´åŠ ä¸€ç›®äº†ç„¶ã€‚

ä½¿ç”¨`patch`è¦ç‰¹åˆ«æ³¨æ„è¦æ›¿ä»£çš„å¯¹è±¡å®šä½ä¸èƒ½é”™ï¼ˆå‚è§[Mock patching for 'from/import' statement in Python](/python/2016/09/13/Mock-patching-for-fromimport-statement-in-Python)ï¼‰ï¼Œå…¶ä»–ç›´æ¥çœ‹ä¸‹é¢çš„ä¾‹å­å°±è¡Œï¼š

```python
from mock import patch


def foo():
    return 'foo'


# patch can simply used by only inputting the target object that need to replaced.
# In this situation, you must append an argument to the method's input. This argument is a MagicMock object generated by patch decorator.
# So you can change the return value of the MagicMock object which will be the return value of calling the replaced object.
@patch('__main__.foo')
def test_one(mock_fuc):
    mock_fuc.return_value = 'bar'
    print foo
    print foo()
    # One goodness of inputting MagicMock object into method is here: you can make some assert of the mock object.
    mock_fuc.assert_called_once_with()
    print mock_fuc.call_count


def bar():
    return 'bar'


# patch can also used by inputting the replaced object in the decorator.
# In this situation, you do not need to append an argument to the method's input.
@patch('__main__.foo', bar)
def test_two():
    print foo
    print foo()


# Besides decorator, you can also use patch as `with` statement.
def test_three():
    with patch('__main__.foo', bar):
        print foo
        print foo()
    print foo
    print foo()


# Besides `with` statement, you can also control the scope by patch.start() and patch.stop() methods.
# This is more flexible than the methods above, and can be useful when patch with several test cases.
def test_four():
    patcher = patch('__main__.foo', bar)
    patcher.start()
    print foo
    print foo()
    patcher.stop()
    print foo
    print foo()


# Can use several patch at the same time.
# When inputting the MagicMock objects to the method, notice the sequence of the MagicMock objects is reverse to the decorators.
@patch('__main__.foo')
@patch('__main__.bar')
def test_five(mock_bar, mock_foo):
    mock_foo.return_value = 'zzz'
    mock_bar.return_value = 'mew'
    print foo
    print foo()
    print bar
    print bar()


if __name__ == '__main__':
    test_one()
    test_two()
    test_three()
    test_four()
    test_five()
```

### patch.object, patch.dict, patch.multiply

è¿™ä¸‰ä¸ªä¸œè¥¿å…¶å®å°±æ˜¯è®©ä½ å°‘äº›äº†å‡ è¡Œä»£ç ï¼Œå½“ç„¶ç”¨è¿˜æ˜¯è›®å¥½ç”¨çš„ï¼š

```python
from mock import patch, DEFAULT


class Real(object):
    def foo(self):
        return 'foo'

    def bar(self):
        return 'bar'


# Use `patch.object` to replace only one attribute of the object.
# (This function can be also implemented by `patch`, but this is more convenient)
@patch.object(Real, 'foo')
def test_one(mock_foo):
    mock_foo.return_value = 'zzz'
    foo = Real()
    print foo.foo()
    print foo.bar()


real_dict = {'foo': 1, 'bar': 2, 'zzz': 3}


# Use `patch.dict` to 'revise' a dict like object conveniently.
@patch.dict(real_dict, foo=2, bar=3)
def test_two():
    print real_dict


# Use `patch.multiple` to replace several objects in the same module.
@patch.multiple('__main__', real_dict={}, Real=DEFAULT)
def test_three(Real):
    print real_dict
    print Real


if __name__ == '__main__':
    test_one()
    test_two()
    test_three()
```

### patch.TEST_PREFIX

å› ä¸º`mock`è¿™ä¸ªåº“æœ¬èº«æ˜¯ä¸ºæµ‹è¯•è€Œå†™å‡ºæ¥çš„ï¼Œåœ¨Python 3ä¸­ä¹Ÿæ˜¯ä½œä¸ºunitteståº“çš„ä¸€éƒ¨åˆ†å­˜åœ¨çš„ï¼Œæ‰€ä»¥å®ƒé»˜è®¤åªä¼šæ›¿æ¢æµ‹è¯•æ–¹æ³•ä¸­çš„å¯¹è±¡ï¼Œè€Œignoreéæµ‹è¯•æ–¹æ³•ã€‚ç°åœ¨ä¸»æµçš„æµ‹è¯•æ¡†æ¶å¯¹æµ‹è¯•æ–¹æ³•çš„åˆ¤æ–­å°±æ˜¯çœ‹å®ƒæ˜¯ä¸æ˜¯ä»¥`test`ä¸ºå¼€å¤´å‘½åçš„ï¼Œæ‰€ä»¥`mock`ä¹Ÿæ˜¯è¿™ä¹ˆåˆ¤æ–­çš„ã€‚

å¦‚æœç”¨`mock`ä¸æ˜¯ç”¨äºæµ‹è¯•ï¼Œå¯ä»¥ä¿®æ”¹`patch.TEST_PREFIX`çš„å€¼æ¥è®©å®ƒç”Ÿæ•ˆï¼š

```python
from mock import patch

# By default, the patchers recognise methods that start with 'test' as being test methods.
# We set the prefix to `foo` here so that the patch will influence all the methods whose name start with `foo`
patch.TEST_PREFIX = 'foo'
value = 3


@patch('__main__.value', 'not three')
class Thing(object):
    def foo_one(self):
        print value

    def foo_two(self):
        print value

    def bar_one(self):
        print value


if __name__ == '__main__':
    t = Thing()
    t.foo_one()
    t.foo_two()
    t.bar_one()
```

### An example

æœ€åçœ‹ä¸‹å®˜æ–¹æ–‡æ¡£çš„ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘æ·»åŠ äº†ä¸€äº›æ³¨é‡Šï¼š

```python
from mock import patch


class Foo(object):
    def print_foo(self):
        return 'foo'


def some_function():
    instance = Foo()
    print instance
    return instance.print_foo()


if __name__ == '__main__':
    # Will create a MagicMock object to replace class `Foo`
    with patch("__main__.Foo") as MockFoo:
        # Call the MagicMock object will return a new MagicMock object and is bounded with the calling MockFoo()
        # (means each time you call MockFoo()/Foo(), will return the same MagicMock object)
        mock_instance = MockFoo.return_value
        # Set the print_foo()'s return value to 'bar'
        mock_instance.print_foo.return_value = 'bar'
        print mock_instance
        # Call the function which calls Foo.print_foo(), this actually calls the mock_instance.print_foo()
        result = some_function()
        assert result == 'bar'
```



